include ../_util-fns

<a id="top"></a>
:marked
  GraphQL is a network protocol, a query language for your API and a runtime for fulfilling those queries with your existing data.

.l-sub-section
  :marked
    You can think about it as a replacement/enhancement for REST (but you can use them both alongside each other)

:marked
  GraphQL provides a complete and understandable description of the data in your API, gives clients the power to ask for exactly what they need and nothing more, makes it easier to evolve APIs over time, and enables powerful developer tools.


<a id="toc"></a>
:marked
  ## Table of contents
  
  - [What is GraphQL](#what-is-graphql)

  - [The benefits of GraphQL to Angular developers](#benefits-of-graphql)

  - [How to use GraphQL in your Angular app with app demo:](#how-to)
    - [Installation](#installation)

    - [Performing a query](#querying)
  
    - [Performing a mutation](#mutation)

  - [Further resources](#resources)

  - [Appendix: Setting up a GraphQL server](#server)

  - [Full Example](#example)

:marked
  **See the <live-example name="heroes-graphql"></live-example>**.

.l-main-section
<a id="what-is-graphql"></a>
:marked
  ## What is GraphQL
  
  GraphQL is an API query language, helping your Angular app to:
   
  - Fetch exactly the information it needs from your server
  - Adds type safety to your API
  - Merge multiple dependencies into one single response from the server
  - Handle server data dependency in a component structure
  
  It’s also important to understand that:
  
  - **GraphQL is not a data source** - The GraphQL runtime works on top of any data source - 
  SQL, NoSql, REST, Queues, .NET servers, Java servers or any other technology or data source
  - GraphQL solves the need of sending multiple requests for multiple resources to the server and then running complex joins on the client - 
  without the need to create a custom endpoint like REST does
  - The GraphQL spec also includes protocols for real-time push updates from the server to the client

  The best source for learning about GraphQL is the http://graphql.org/ website.
  
.l-main-section
<a id="benefits-of-graphql"></a>
:marked
  ## The benefits of GraphQL to Angular developers

.l-sub-section
  :marked
    You can check out [this](https://www.youtube.com/watch?v=Xx39bv-5ojA&t=1s) talk by [Jeff Cross](https://twitter.com/jeffbcross) and
    [Uri Goldshtein](https://twitter.com/UriGoldshtein) that summarizes this part

:marked
  ### Component based API
  
  In Angular, our app is made out of Components.
  
  The obvious benefits of using components are:
  - Encapsulation of behaviour and state
  - Composable and reusable
  
  So how can we keep those benefits when we fetch data from the server?
  Without GraphQL, we have 3 possible solutions:
  
  1. Using the HTTP service inside our components
  2. Calling a service from our component
  3. Fetch data at the parent component and pass it down the component tree
  
  All those solutions are valid but also has their limitations:
  
  #### Using HTTP service in Component  

  The problems with that approach:

  1. Multiple redundant requests - When we render multiple components, 
  sometime through ngFor with many components, each will send its own HTTP call and they might be redundant
  2. Inconsistent data - if two components fetch the same data but in different requests,
  the data might change and not be consistent across the app
  
  #### Using a service
  
+makeExample('toh-6/ts/app/hero.service.ts', 'getHero','hero.service.ts (Fetch by Id)')
+makeExample('toh-6/ts/app/hero-detail.component.ts', 'service-fetch-by-id','hero-detail.component.ts (Fetch by Id)')
:marked
  The problems with that approach:
    
  1. We created a dependency between the service and all of the components that use it - 
  making the component no longer reusable 
  (if we change something in the service, we might break other components that use that service)
  2. We created a main, complex point to handle batching, caching and join logic
  
  #### Fetch data at the parent component and pass it down the component tree
  
+makeExample('toh-4/ts/app/hero.ts','','Declare the API type')
+makeExample('toh-4/ts/app/hero-detail.component.ts','declaring-conponent-input','Declare the input')
+makeExample('toh-4/ts/app/app.component.ts','calling-component','Using from parent')
:marked
  The problems with that approach:

  - When you change the API of a component, you need to change its parent components all the way to the top - 
  so again we created a dependency, this time with the child component all the way up to the fetching component
  and all the components in between
  
  #### Solution - Component based API
  
+makeExample('heroes-graphql/ts/app/hero-detail.component.ts','graphql-query','GraphQL query')
:marked
  As you can see, we placed the data dependency inside or next to the component itself and when the data dependency changes,
  the component is the only thing that needed to be changed -
  no service or parent component were harmed in the making of this component.

  So now when we want to change the data dependencies, all changes are contained within the single component:

+makeExample('heroes-graphql/ts/app/hero-detail.component.1.ts','graphql-query-new-field','Adding `age` field to component')
+makeExample('heroes-graphql/ts/app/hero-detail.component.1.html','template-new-field','Adding `age` field to template')  
:marked
  ### Network Performance
  
  In our Heroes HTTP example, we call `getHeroes` to fetch all heroes and their information.
  
  That might work for simple cases but the problem here is that we might fetch more information than we really need for each hero.
  And now we created a dependency between the server endpoint and our UI component - if we change or limit the amount of information we send on the server, we might break the components that use that endpoint.
  
  The other approach would be to call `getHeroes`, get the ids of the heroes and call `getHero` for each id.
  That might result in multiple requests to the server for one single render of our page.
  
  With REST API, we would always have to choose between those two options and the problems of each option.
  
  But with GraphQL, we just specify the dependency of each component and a GraphQL client library, like [Apollo-Client](http://dev.apollodata.com/), 
  will merge those into one single network request and GraphQL will send back the information in one single response, with exactly the information we need - 
  no more, no less and no need to do complex joins and waiting to responses on the client.
  
  > Example
  
  ### Typed API and tooling
  
  By now, we all understand the benefits of Typescript for our code.
  It give us better tooling to increase our productivity, verifying that the code we write is safe.

  Why don’t we do the same for our API?  Where sometimes is written by another team and we can’t really know what is going to change there?

  With GraphQL, the schema is typed and shared between the client and the server so we can get the same benefits when working with the network - validation and autocompletion inside our IDE at development time!


  IDE GIF

  
.l-main-section
<a id="how-to"></a>
:marked
  ## How to use GraphQL in your Angular app

  We will use [Apollo-Client](http://dev.apollodata.com/) as our GraphQL client for Angular.  
  Apollo does more then simply querying GraphQL and also gives us the benefits we talked before like distributing
  queries to Angular components. 

.l-sub-section
  :marked
    This will be a quick start guide, the full documentation can be found on the [Apollo Client docs website](http://dev.apollodata.com/)

.l-main-section
<a id="installation"></a>
:marked
  ## Installation

  First, let's install Apollo-Client and the integration libraries from npm:

code-example(language="sh" class="code-shell").
    npm install apollo-client apollo-angular graphql-tag --save
:marked
  Now let's initialize our client.

  Create a new file called `client.ts` and place the following code:
+makeExample('heroes-graphql/ts/app/client.1.ts')
:marked
  This is the default initialization of Apollo and will call the `/graphql` endpoint.

  In order to change the [settings](http://dev.apollodata.com/core/apollo-client-api.html#ApolloClient\.constructor) of Apollo client,
  we will call it's constructor with different parameters, for example in order to change the endpoint we will do something like that:
+makeExample('heroes-graphql/ts/app/client.2.ts', 'network-initialization')
.l-sub-section
  :marked
    If you don't have a GraphQL server running, [jump to the section about creating a GraphQL server](#server).
    In that example we will show you how to run your GraphQL server in-memory on the client, as it is good for testing and also
    a helpful way to gradually move your app to GraphQL.

:marked
  Once we've finished initializing our Apollo-Client, we would want to add the Apollo module to our app's NgNodules with our configurations:
+makeExample('heroes-graphql/ts/app/app.module.ts', 'import-apollo', 'app.module.ts (npm imports)')
+makeExample('heroes-graphql/ts/app/app.module.ts', 'apollo-ngmodule', 'app.module.ts (NgModule)')

.l-main-section
<a id="querying"></a>
:marked
  ## Performing a query

  In GraphQL we always query a server which has a schema representing the data it exposes.
  Our server is built based on the Heroes tutorial and here is the schema:
+makeExample('heroes-graphql/ts/app/in-memory-graphql.ts', 'graphql-schema', 'Heroes GraphQL Schema')
:marked
  So let's start by adding Apollo into our Component, let's import it and inject with in the constructor:
+makeExample('heroes-graphql/ts/app/heroes.component.ts', 'import-apollo', 'heroes.component.ts')
+makeExample('heroes-graphql/ts/app/heroes.component.ts', 'inject-apollo', 'heroes.component.ts')
:marked
  To query data with Apollo Client we just need to pass Apollo a query in the GraphQL query syntax, explained [here](http://graphql.org/learn/queries/).

  In order to parse regular string literals as GraphQL, we will use the `gql` function from the `graphql-tag` library:
+makeExample('heroes-graphql/ts/app/heroes.component.ts', 'import-graphql-tag', 'heroes.component.ts')
:marked
  Now let's query:
+makeExample('heroes-graphql/ts/app/heroes.component.ts', 'query-heroes', 'heroes.component.ts')
:marked
  and render:
+makeExample('heroes-graphql/ts/app/heroes.component.1.html', 'render-heroes', 'heroes.component.html')


.l-main-section
<a id="mutation"></a>
:marked
  ## Performing a mutation

  In addition to fetching data using queries, GraphQL also makes it possible to change data through mutations.

  Mutations are identical to queries in syntax, the only difference being that you use the keyword `mutation` instead of `query` to indicate that you are performing writes to the backend.
  
.l-sub-section
  :marked
    You can look at it as the equivalent of POST request in REST
:marked
code-example(language="json").
  mutation {
    addHero(heroName: "Russell Brand") {
      id
      name
    }
  }
:marked
  GraphQL mutations consist of two parts:
  1. The mutation name with arguments (`addHero`), which represents the actual operation to be done on the server (just like calling a function)
  2. The fields you want back from the result of the mutation to update the client (`id` and `name`) - which is very powerful - You, as the client developer can 
  decide which fields you will get back, not something that the server will dictate for you

  The result of the above mutation might be be:
code-example(language="json").  
  {
    "data": {
      "addHero": {
        "id": "69",
        "name": "Russel Brand"
      }
    }
  }
.l-sub-section
  :marked
    You can get deep into the mutation syntax on the [GraphQL.org website](http://graphql.org/learn/queries/#mutations)
:marked
  So first let's add a local function to add a hero to our template:
+makeExample('heroes-graphql/ts/app/heroes.component.html', 'add', 'heroes.component.html')  
:marked
  and component:
+makeExample('heroes-graphql/ts/app/heroes.component.1.ts', 'add', 'heroes.component.ts')
:marked
  and now let's add an `addHero` mutation to that function using the `apollo.mutate` function:
+makeExample('heroes-graphql/ts/app/heroes.component.ts', 'add-mutation', 'heroes.component.ts')
:marked
  You can see, that our mutation requires and variable and we pass it to the `mutate` function through the `variables` param.

  Also, just like a query, the mutate function returns an Observable we can subscribe to and handle the data we asked for.
  
.l-main-section
<a id="resources"></a>
:marked
  ## Further resources

  * [GraphQL.org](http://graphql.org/) is a great website, with the following sections 
  (by the way, all the examples on the website are runing live, try to edit them in the browser while you reading it):
    * [Learn](http://graphql.org/learn/)
    * [Implementations in any language](http://graphql.org/code/)
    * [Community](http://graphql.org/community/)
  * [Apollo Developer resources](http://dev.apollodata.com/) - The [team](http://www.apollodata.com/) behind the Angular GraphQL client, 
  there you will find a more advanced resources about:
    * [Handling updates from the server and managing the local store](http://dev.apollodata.com/angular2/receiving-updates.html)
    * [Authentication](http://dev.apollodata.com/angular2/auth.html)
    * [Pagination](http://dev.apollodata.com/angular2/pagination.html)
    * [Server-side rendering](http://dev.apollodata.com/angular2/server-side-rendering.html)
    * and more..
  * [Apollo Dev Blog](https://dev-blog.apollodata.com/) - The most popular GraphQL blog
  * [Apollo Client Developer Tools](https://dev-blog.apollodata.com/apollo-client-developer-tools-ff89181ebcf#.n5f3fhbg2) - GraphQL debugging tools for Apollo Client in the Chrome developer console

.l-main-section
<a id="server"></a>
:marked
  ## Appendix: Setting up a GraphQL server

  We are going to show you how to add a GraphQL server in Javascript.

  Like the other examples on angular.io, we are going to run the server in the browser as part of our Angular app,
  it's good for testing and also if you want to start using GraphQL on your frontend without having a GraphQL backend.

.l-sub-section
  :marked
    You can learn how to run a full GraphQL backend on the [Apollo Server docs](http://dev.apollodata.com/tools/).  
    The good thing is, that because it's Isomorphic Javascript, it is almost identical to the simple server we will run inside our Angular app
    so everything we'll learn now will be the same when you would want to move to write a GraphQL backend.

    Also, there are few GraphQL based Backend-as-a-service platforms out there, like Firebase but based on GraphQL API, to help get
    started really fast - https://www.scaphold.io/ https://www.graph.cool/ 
:marked
  To start, let's create a file called `in-memory-graphql.ts` inside our Angular app.

  First thing we should do is to create our GraphQL schema.

  For that we will use the `graphql-tools` library that let's us write a GraphQL schema as a string and make it executable:
code-example(language="sh" class="code-shell").
    npm install graphql-tools --save  
:marked
  Now for the schema itself:    
+makeExample('heroes-graphql/ts/app/in-memory-graphql.ts', 'graphql-schema', 'Heroes GraphQL Schema')
.l-sub-section
  :marked
    The schema is pretty self explanatory, but if you want to dig deeper, check out [GraphQL.org `learn` section](http://graphql.org/learn/)
:marked
  Next let's create our in-memory data:  
+makeExample('heroes-graphql/ts/app/in-memory-graphql.ts', 'heroes-array', 'Heroes Array')
:marked
  Now we need to write a server that will resolve the queries that we will get from the client based on the schema.
  
  The GraphQL server consists of resolver functions that correspond to the types of the schema.
.l-sub-section
  :marked
    For the full explanation about how GraphQL resolvers work check out the [execution section](http://graphql.org/learn/execution/) of GraphQL.org 
:marked
  Let's create our resolvers:
+makeExample('heroes-graphql/ts/app/in-memory-graphql.ts', 'resolvers', 'Resolvers')
:marked
  We also used some functions from `lodash` so don't forget to install them from npm and import them:
+makeExample('heroes-graphql/ts/app/in-memory-graphql.ts', 'import-lodash', 'Importing lodash')
:marked
  As you can see, we created functions that correspond to each type of our schema and also to the mutations.

  This mechanism makes writing simple GraphQL servers very easy, you simply think about how to resolve a specific type of data,
  separates the frontend logic from the backend, removing the coupling between frontend and backend.

.l-sub-section
  :marked
    Also in case you don't have the option to run GraphQL on the server, it's much easier to handle multiple REST requests and join logic on the client using these tools
:marked
  Now we need to connect the shema to the resolvers with the `makeExecutableSchema` function from 
  the [graphql-tools](http://dev.apollodata.com/tools/graphql-tools/index.html) library:
+makeExample('heroes-graphql/ts/app/in-memory-graphql.ts', 'import-graphql-tools', 'importing graphql-tools')
+makeExample('heroes-graphql/ts/app/in-memory-graphql.ts', 'make-executable-schema', 'makeExecutableSchema')
:marked
  Now that we have executable schema, let's execute it using the `graphql` library and export it so we can use it in our Apollo Client:
+makeExample('heroes-graphql/ts/app/in-memory-graphql.ts', 'import-graphql', 'Dont forget to npm install')
+makeExample('heroes-graphql/ts/app/in-memory-graphql.ts', 'execute-and-export', 'Execute and export')
:marked
  Now all that's left is to connect the new in-memory server into our Apollo Client configuration:
+makeExample('heroes-graphql/ts/app/client.ts', '', 'client.ts')
:marked
  That's it.  now you can run your application as if you had a GraphQL server connected to it but, 
  there is no persistance - everything is running in-memory browser right now, so when you refresh the page, all changes will be lost.

  more things you can do now that you have it setup:
  * You can store everything on the browser's local-storage using local-storage database libraries
  * You can make the resolver functions call your server's existing REST endpoint
  * You can start a separate Node GraphQL server and simply move the code in there - 
  now you will have persistance and you became a backend developer ;)

.l-main-section
<a id="example"></a>
:marked
  ## Full Example  

block file-summary
  +makeTabs(
    `heroes-graphql/ts/app/app.component.ts,
     heroes-graphql/ts/app/app.module.ts,
     heroes-graphql/ts/app/heroes.component.ts,
     heroes-graphql/ts/app/heroes.component.html,
     heroes-graphql/ts/app/heroes.component.css,
     heroes-graphql/ts/app/hero-detail.component.ts,
     heroes-graphql/ts/app/hero-detail.component.html,
     heroes-graphql/ts/app/in-memory-graphql.ts,
     heroes-graphql/ts/app/client.ts`,
    ',,,,,,,,',
    `app.comp...ts,
     app.mod...ts,
     heroes.comp...ts,
     heroes.comp...html,
     heroes.comp...css,
     hero-detail.comp...ts,
     hero-detail.comp...html,
     in-memory-graphql.ts,
     client.ts`
  )

  +makeTabs(
   `toh-6/ts/app/app-routing.module.ts,
    toh-6/ts/app/hero-search.component.ts,
    toh-6/ts/app/hero-search.component.html,
    toh-6/ts/app/hero-search.component.css,
    toh-6/ts/app/rxjs-extensions.ts`,
    null,
   `app-routing.modules.ts,
    hero-search.component.ts,
    hero-search.component.html,
    hero-search.component.css,
    rxjs-extensions.ts`
  )

:marked
  [Back to top](#top)
