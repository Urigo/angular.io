include ../_util-fns

<a id="top"></a>
:marked
  GraphQL is a network protocol, a query language for your API and a runtime for fulfilling those queries with your existing data.

.l-sub-section
  :marked
    You can think about it as a replacement/enhancement for REST (but you can use them both alongside each other)

:marked
  GraphQL provides a complete and understandable description of the data in your API, gives clients the power to ask for exactly what they need and nothing more, makes it easier to evolve APIs over time, and enables powerful developer tools.


<a id="toc"></a>
:marked
  ## Table of contents
  
  - [What is GraphQL](#what-is-graphql)

  - [The benefits of GraphQL to Angular developers](#benefits-of-graphql)

  - [How to use GraphQL in your Angular app with app demo:](#how-to)
    - [Installation](#installation)

    - [Performing a query](#querying)
  
    - [Performing a mutation](#mutation)
  
    - [Querying a realtime subscription](#more-observables)

  - [Further resources](#parent-to-child-setter)

  - [Appendix: Setting up a GraphQL server](#parent-to-child-setter)

:marked
  **See the <live-example name="heroes-graphql"></live-example>**.

.l-main-section
<a id="what-is-graphql"></a>
:marked
  ## What is GraphQL
  
  GraphQL is an API query language, helping your Angular app to:
   
  - Fetch exactly the information it needs from your server
  - Adds type safety to your API
  - Merge multiple dependencies into one single response from the server
  - Handle server data dependency in a component structure
  
  It’s also important to understand that:
  
  - **GraphQL is not a data source** - The GraphQL runtime works on top of any data source - 
  SQL, NoSql, REST, Queues, .NET servers, Java servers or any other technology or data source
  - GraphQL solves the need of sending multiple requests for multiple resources to the server and then running complex joins on the client - 
  without the need to create a custom endpoint like REST does
  - The GraphQL spec also includes protocols for real-time push updates from the server to the client

  The best source for learning about GraphQL is the http://graphql.org/ website.
  
.l-main-section
<a id="benefits-of-graphql"></a>
:marked
  ## The benefits of GraphQL to Angular developers

.l-sub-section
  :marked
    You can check out [this](https://www.youtube.com/watch?v=Xx39bv-5ojA&t=1s) talk by [Jeff Cross](https://twitter.com/jeffbcross) and
    [Uri Goldshtein](https://twitter.com/UriGoldshtein) that summarizes this part

:marked
  ### Component based API
  
  In Angular, our app is made out of Components.
  
  The obvious benefits of using components are:
  - Encapsulation of behaviour and state
  - Composable and reusable
  
  So how can we keep those benefits when we fetch data from the server?
  Without GraphQL, we have 3 possible solutions:
  
  1. Using the HTTP service inside our components
  2. Calling a service from our component
  3. Fetch data at the parent component and pass it down the component tree
  
  All those solutions are valid but also has their limitations:
  
  #### Using HTTP service in Component  

  The problems with that approach:

  1. Multiple redundant requests - When we render multiple components, 
  sometime through ngFor with many components, each will send its own HTTP call and they might be redundant
  2. Inconsistent data - if two components fetch the same data but in different requests,
  the data might change and not be consistent across the app
  
  #### Using a service
  
+makeExample('toh-6/ts/app/hero.service.ts', 'getHero','hero.service.ts (Fetch by Id)')
+makeExample('toh-6/ts/app/hero-detail.component.ts', 'service-fetch-by-id','hero-detail.component.ts (Fetch by Id)')
:marked
  The problems with that approach:
    
  1. We created a dependency between the service and all of the components that use it - 
  making the component no longer reusable 
  (if we change something in the service, we might break other components that use that service)
  2. We created a main, complex point to handle batching, caching and join logic
  
  #### Fetch data at the parent component and pass it down the component tree
  
+makeExample('toh-4/ts/app/hero.ts','','Declare the API type')
+makeExample('toh-4/ts/app/hero-detail.component.ts','declaring-conponent-input','Declare the input')
+makeExample('toh-4/ts/app/app.component.ts','calling-component','Using from parent')
:marked
  The problems with that approach:

  - When you change the API of a component, you need to change its parent components all the way to the top - 
  so again we created a dependency, this time with the child component all the way up to the fetching component
  and all the components in between
  
  #### Solution - Component based API
  
+makeExample('heroes-graphql/ts/app/hero-detail.component.ts','graphql-query','GraphQL query')
:marked
  As you can see, we placed the data dependency inside or next to the component itself and when the data dependency changes,
  the component is the only thing that needed to be changed -
  no service or parent component were harmed in the making of this component.

  So now when we want to change the data dependencies, all changes are contained within the single component:

+makeExample('heroes-graphql/ts/app/hero-detail.component.1.ts','graphql-query-new-field','Adding `age` field to component')
+makeExample('heroes-graphql/ts/app/hero-detail.component.1.html','template-new-field','Adding `age` field to template')  
:marked
  ### Network Performance
  
  In our Heroes HTTP example, we call `getHeroes` to fetch all heroes and their information.
  
  That might work for simple cases but the problem here is that we might fetch more information than we really need for each hero.
  And now we created a dependency between the server endpoint and our UI component - if we change or limit the amount of information we send on the server, we might break the components that use that endpoint.
  
  The other approach would be to call `getHeroes`, get the ids of the heroes and call `getHero` for each id.
  That might result in multiple requests to the server for one single render of our page.
  
  With REST API, we would always have to choose between those two options and the problems of each option.
  
  But with GraphQL, we just specify the dependency of each component and a GraphQL client library, like [Apollo-Client](http://dev.apollodata.com/), 
  will merge those into one single network request and GraphQL will send back the information in one single response, with exactly the information we need - 
  no more, no less and no need to do complex joins and waiting to responses on the client.
  
  > Example
  
  ### Typed API and tooling
  
  By now, we all understand the benefits of Typescript for our code.
  It give us better tooling to increase our productivity, verifying that the code we write is safe.

  Why don’t we do the same for our API?  Where sometimes is written by another team and we can’t really know what is going to change there?

  With GraphQL, the schema is typed and shared between the client and the server so we can get the same benefits when working with the network - validation and autocompletion inside our IDE at development time!


  IDE GIF

  
.l-main-section
<a id="how-to"></a>
:marked
  ## How to use GraphQL in your Angular app

  We will use [Apollo-Client](http://dev.apollodata.com/) as our GraphQL client for Angular.  
  Apollo does more then simply querying GraphQL and also gives us the benefits we talked before like distributing
  queries to Angular components. 

.l-sub-section
  :marked
    This will be a quick start guide, the full documentation can be found on the [Apollo Client docs website](http://dev.apollodata.com/)

.l-main-section
<a id="installation"></a>
:marked
  ## Installation

  First, let's install Apollo-Client and the integration libraries from npm:

code-example(language="sh" class="code-shell").
    npm install apollo-client apollo-angular graphql-tag --save
:marked
  Now let's initialize our client.

  Create a new file called `client.ts` and place the following code:
+makeExample('heroes-graphql/ts/app/client.1.ts')
:marked
  This is the default initialization of Apollo and will call the `/graphql` endpoint.

  In order to change the [settings](http://dev.apollodata.com/core/apollo-client-api.html#ApolloClient\.constructor) of Apollo client,
  we will call it's constructor with different parameters, for example in order to change the endpoint we will do something like that:
+makeExample('heroes-graphql/ts/app/client.2.ts', 'network-initialization')
.l-sub-section
  :marked
    If you don't have a GraphQL server running, jump to the section about creating a GraphQL server.
    In that example we will show you how to run your GraphQL server in-memory on the client, as it is good for testing and also
    a helpful way to gradually move your app to GraphQL.

:marked
  Once we've finished initializing our Apollo-Client, we would want to add the Apollo module to our app's NgNodules with our configurations:
+makeExample('heroes-graphql/ts/app/app.module.ts', 'import-apollo', 'app.module.ts (npm imports)')
+makeExample('heroes-graphql/ts/app/app.module.ts', 'apollo-ngmodule', 'app.module.ts (NgModule)')

.l-main-section
<a id="querying"></a>
:marked
  ## Performing a query

  In GraphQL we always query a server which has a schema representing the data it exposes.
  Our server is built based on the Heroes tutorial and here is the schema:
+makeExample('heroes-graphql/ts/app/in-memory-graphql.ts', 'graphql-schema', 'Heroes GraphQL Schema')
:marked
  So let's start by adding Apollo into our Component, let's import it and inject with in the constructor:
+makeExample('heroes-graphql/ts/app/heroes.component.ts', 'import-apollo', 'heroes.component.ts')
+makeExample('heroes-graphql/ts/app/heroes.component.ts', 'inject-apollo', 'heroes.component.ts')
:marked
  To query data with Apollo Client we just need to pass Apollo a query in the GraphQL query syntax, explained [here](http://graphql.org/learn/queries/).

  In order to parse regular string literals as GraphQL, we will use the `gql` function from the `graphql-tag` library:
+makeExample('heroes-graphql/ts/app/heroes.component.ts', 'import-graphql-tag', 'heroes.component.ts')
:marked
  Now let's query:
+makeExample('heroes-graphql/ts/app/heroes.component.ts', 'query-heroes', 'heroes.component.ts')
:marked
  and render:
+makeExample('heroes-graphql/ts/app/heroes.component.1.html', 'render-heroes', 'heroes.component.html')


.l-main-section
<a id="mutation"></a>
:marked
  ## Performing a mutation

  In addition to fetching data using queries, GraphQL also makes it possible to change data through mutations.

  Mutations are identical to queries in syntax, the only difference being that you use the keyword `mutation` instead of `query` to indicate that you are performing writes to the backend.
  
.l-sub-section
  :marked
    You can look at it as the equivalent of POST request in REST
:marked
code-example(language="sh" class="code-shell").
  mutation {
    addHero(heroName: "Russel Brand") {
      id
      name
    }
  }
  age="html" format="linenums").
  format="linenums" language="typescript").
  format="linenums" language="js").
  code-example(language="json").
:marked
  GraphQL mutations consist of two parts:
  1. The mutation name with arguments (`addHero`), which represents the actual operation to be done on the server (just like calling a function)
  2. The fields you want back from the result of the mutation to update the client (`id` and `name`) - which is very powerful - You, as the client developer can 
  decide which fields you will get back, not something that the server will dictate for you

  The result of the above mutation might be be:
code-example(language="json" class="code-shell").  
  {
    "data": {
      "addHero": {
        "id": "69",
        "name": "Russel Brand"
      }
    }
  }
.l-sub-section
  :marked
    You can get deep into the mutation syntax on the [GraphQL.org website](http://graphql.org/learn/queries/#mutations)
:marked
  So first let's add a local function to add a hero to our template:
+makeExample('heroes-graphql/ts/app/heroes.component.html', 'add', 'heroes.component.html')  
:marked
  and component:
+makeExample('heroes-graphql/ts/app/heroes.component.1.ts', 'add', 'heroes.component.ts')
:marked
  and now let's add an `addHero` mutation to that function using the `apollo.mutate` function:
+makeExample('heroes-graphql/ts/app/heroes.component.ts', 'add-mutation', 'heroes.component.ts')
:marked
  You can see, that our mutation requires and variable and we pass it to the `mutate` function through the `variables` param.

  Also, just like a query, the mutate function returns an Observable we can subscribe to and handle the data we asked for.
  
:marked
  [Back to top](#top)
