include ../_util-fns

<a id="top"></a>
:marked
  GraphQL is a network protocol, a query language for your API and a runtime for fulfilling those queries with your existing data.

.l-sub-section
  :marked
    You can think about it as a replacement/enhancement for REST (but you can use them both alongside each other)

:marked
  GraphQL provides a complete and understandable description of the data in your API, gives clients the power to ask for exactly what they need and nothing more, makes it easier to evolve APIs over time, and enables powerful developer tools.


<a id="toc"></a>
:marked
  ## Table of contents
  
  - [What is GraphQL](#what-is-graphql)

  - [The benefits of GraphQL to Angular developers](#benefits-of-graphql)

  - [How to use GraphQL in your Angular app with app demo:](#how-to)
    - [Installation](#installation)

    - [Performing a query](#querying)
  
    - [Performing a mutation](#mutation)
  
    - [Querying a realtime subscription](#more-observables)

  - [Further resources](#parent-to-child-setter)

  - [Appendix: Setting up a GraphQL server](#parent-to-child-setter)

:marked
  **See the <live-example name="heroes-graphql"></live-example>**.

.l-main-section
<a id="what-is-graphql"></a>
:marked
  ## What is GraphQL
  
  GraphQL is an API query language, helping your Angular app to:
   
  - Fetch exactly the information it needs from your server
  - Adds type safety to your API
  - Merge multiple dependencies into one single response from the server
  - Handle server data dependency in a component structure
  
  It’s also important to understand that:
  
  - **GraphQL is not a data source** - The GraphQL runtime works on top of any data source - 
  SQL, NoSql, REST, Queues, .NET servers, Java servers or any other technology or data source
  - GraphQL solves the need of sending multiple requests for multiple resources to the server and then running complex joins on the client - 
  without the need to create a custom endpoint like REST does
  - The GraphQL spec also includes protocols for real-time push updates from the server to the client

  The best source for learning about GraphQL is the http://graphql.org/ website.
  
.l-main-section
<a id="benefits-of-graphql"></a>
:marked
  ## The benefits of GraphQL to Angular developers

.l-sub-section
  :marked
    You can check out [this](https://www.youtube.com/watch?v=Xx39bv-5ojA&t=1s) talk by [Jeff Cross](https://twitter.com/jeffbcross) and
    [Uri Goldshtein](https://twitter.com/UriGoldshtein) that summarizes this part

:marked
  ### Component based API
  
  In Angular, our app is made out of Components.
  
  The obvious benefits of using components are:
  - Encapsulation of behaviour and state
  - Composable and reusable
  
  So how can we keep those benefits when we fetch data from the server?
  Without GraphQL, we have 3 possible solutions:
  
  1. Using the HTTP service inside our components
  2. Calling a service from our component
  3. Fetch data at the parent component and pass it down the component tree
  
  All those solutions are valid but also has their limitations:
  
  #### Using HTTP service in Component  

  The problems with that approach:

  1. Multiple redundant requests - When we render multiple components, 
  sometime through ngFor with many components, each will send its own HTTP call and they might be redundant
  2. Inconsistent data - if two components fetch the same data but in different requests,
  the data might change and not be consistent across the app
  
  #### Using a service
  
+makeExample('toh-6/ts/app/hero.service.ts', 'getHero','hero.service.ts (Fetch by Id)')
+makeExample('toh-6/ts/app/hero-detail.component.ts', 'service-fetch-by-id','hero-detail.component.ts (Fetch by Id)')
:marked
  The problems with that approach:
    
  1. We created a dependency between the service and all of the components that use it - 
  making the component no longer reusable 
  (if we change something in the service, we might break other components that use that service)
  2. We created a main, complex point to handle batching, caching and join logic
  
  #### Fetch data at the parent component and pass it down the component tree
  
+makeExample('toh-4/ts/app/hero.ts','','Declare the API type')
+makeExample('toh-4/ts/app/hero-detail.component.ts','declaring-conponent-input','Declare the input')
+makeExample('toh-4/ts/app/app.component.ts','calling-component','Using from parent')
:marked
  The problems with that approach:

  - When you change the API of a component, you need to change its parent components all the way to the top - 
  so again we created a dependency, this time with the child component all the way up to the fetching component
  and all the components in between
  
  #### Solution - Component based API
  
+makeExample('heroes-graphql/ts/app/hero-detail.component.ts','graphql-query','GraphQL query')
:marked
  As you can see, we placed the data dependency inside or next to the component itself and when the data dependency changes,
  the component is the only thing that needed to be changed -
  no service or parent component were harmed in the making of this component.

  So now when we want to change the data dependencies, all changes are contained within the single component:

+makeExample('heroes-graphql/ts/app/hero-detail.component.1.ts','graphql-query-new-field','Adding `age` field to component')
+makeExample('heroes-graphql/ts/app/hero-detail.component.1.html','template-new-field','Adding `age` field to template')  

  ### Network Performance
  
  In our Heroes HTTP example, we call `getHeroes` to fetch all heroes and their information.
  
  That might work for simple cases but the problem here is that we might fetch more information that we really need for each hero.
  And now we created a dependency between the server endpoint and our UI component - if we change limit the amount of information we send on the server, we might break the components to use that endpoint.
  
  
  The other approach would be to call `getHeroes`, get the ids of the heroes and call `getHero` for each id.
  That might result in multiple requests to the server for one single render of our page.
  
  With REST API, we would always have to choose between those two options and the problems of each one.
  
  But with GraphQL, we just specify the dependency of each component and a GraphQL client library, like Apollo-Client, will merge those into one single request and GraphQL will send back the information in one single response, with exactly the information we need - 
  no more, no less and no need to do joins and waiting to responses on the client.
  
  > Example
  
  ### Typed API and tooling
  
  By now, we all understand the benefits of Typescript for our code.
  It give us better tooling to increase our productivity, verifying that the code we write is safe.

  Why don’t we do the same of our API?  Where sometimes is written by another team and we can’t really know what is going to change there?

  With GraphQL, the schema is typed so we can get the same benefits when working with the network - validation and autocompletion inside our IDE at development time!


  IDE GIF

  
.l-main-section
<a id="how-to"></a>
:marked
  ## How to use GraphQL in your Angular app

  We will use [Apollo-Client](http://dev.apollodata.com/) as our GraphQL client for Angular.  
  Apollo does more then simply querying GraphQL and also gives us the benefits we talked before like distributing
  queries to Angular components. 

.l-sub-section
  :marked
    This will be a quick start guide, the full documentation can be found on the [Apollo Client docs website](http://dev.apollodata.com/)

.l-main-section
<a id="installation"></a>
:marked
  ## Installation

  First, let's install Apollo-Client and the integration libraries from npm:

code-example(language="sh" class="code-shell").
    npm install apollo-client apollo-angular graphql-tag --save
:marked
  Now let's initialize our client.

  Create a new file called `client.ts` and place the following code:
+makeExample('heroes-graphql/ts/app/client.1.ts')
:marked
  This is the default initialization of Apollo and will call the `/graphql` endpoint.

  In order to change the [settings](http://dev.apollodata.com/core/apollo-client-api.html#ApolloClient\.constructor) of Apollo client,
  we will call it's constructor with different parameters, for example in order to change the endpoint we will do something like that:
+makeExample('heroes-graphql/ts/app/client.2.ts', 'network-initialization')
.l-sub-section
  :marked
    If you don't have a GraphQL server running, jump to the section about creating a GraphQL server.
    In that example we will show you how to run your GraphQL server in-memory on the client, as it is good for testing and also
    a helpful way to gradually move your app to GraphQL.

:marked
  Once we've finished initializing our Apollo-Client, we would want to add the Apollo module to our app's NgNodules with our configurations:
+makeExample('heroes-graphql/ts/app/app.module.ts', 'import-apollo', 'app.module.ts (npm imports)')
+makeExample('heroes-graphql/ts/app/app.module.ts', 'apollo-ngmodule', 'app.module.ts (NgModule)')

.l-main-section
<a id="querying"></a>
:marked
  ## Performing a query

  In GraphQL we always query a server which has a schema representing the data it exposes.
  Our server is built based on the Heroes tutorial and here is the schema:
+makeExample('heroes-graphql/ts/app/in-memory-graphql.ts', 'graphql-schema', 'Heroes GraphQL Schema')
:marked
  So let's start by adding Apollo into our Component, let's import it and inject with in the constructor:
+makeExample('heroes-graphql/ts/app/dashboard.component.ts', 'import-apollo', 'dashboard.component.ts')
+makeExample('heroes-graphql/ts/app/dashboard.component.ts', 'inject-apollo', 'dashboard.component.ts')
:marked
  To query data with Apollo Client we just need to pass Apollo a query in the GraphQL query syntax, explained [here](http://graphql.org/learn/queries/).

  In order to parse regular string literals as GraphQL, we will use the `gql` function from the `graphql-tag` library:
+makeExample('heroes-graphql/ts/app/dashboard.component.ts', 'import-graphql-tag', 'dashboard.component.ts')
:marked
  Now let's query:
+makeExample('heroes-graphql/ts/app/dashboard.component.ts', 'query-heroes', 'dashboard.component.ts')
:marked
  and render:
+makeExample('heroes-graphql/ts/app/dashboard.component.html', 'render-heroes', 'dashboard.component.html')


.l-main-section
<a id="mutation"></a>
:marked
  ## Performing a mutation

  Mutation means 









+makeExample('cb-component-communication/ts/app/hero-child.component.ts')
:marked
  The second `@Input` aliases the child component property name `masterName` as `'master'`.
  
  The `HeroParentComponent` nests the child `HeroChildComponent` inside an `*ngFor` repeater, 
  binding its `master` string property to the child's `master` alias
  and each iteration's `hero` instance to the child's `hero` property.

+makeExample('cb-component-communication/ts/app/hero-parent.component.ts')
:marked
  The running application displays three heroes:
  
figure.image-display
  img(src="/resources/images/cookbooks/component-communication/parent-to-child.png" alt="Parent-to-child")
  
:marked
  ### Test it
  
  E2E test that all children were instantiated and displayed as expected:
  
+makeExample('cb-component-communication/e2e-spec.ts', 'parent-to-child')

:marked
  [Back to top](#top)

.l-main-section
<a id="parent-to-child-setter"></a>
:marked
  ## Intercept input property changes with a setter

  Use an input property setter to intercept and act upon a value from the parent.
  
  The setter of the `name` input property in the child `NameChildComponent` 
  trims the whitespace from a name and replaces an empty value with default text. 
  
+makeExample('cb-component-communication/ts/app/name-child.component.ts')

:marked
  Here's the `NameParentComponent` demonstrating name variations including a name with all spaces:

+makeExample('cb-component-communication/ts/app/name-parent.component.ts')

figure.image-display
  img(src="/resources/images/cookbooks/component-communication/setter.png" alt="Parent-to-child-setter")
  
:marked
  ### Test it

  E2E tests of input property setter with empty and non-empty names:
  
+makeExample('cb-component-communication/e2e-spec.ts', 'parent-to-child-setter')

:marked
  [Back to top](#top)

.l-main-section
<a id="parent-to-child-on-changes"></a>
:marked
  ## Intercept input property changes with *ngOnChanges*

  Detect and act upon changes to input property values with the `ngOnChanges` method of the `OnChanges` lifecycle hook interface.
.l-sub-section
  :marked
    May prefer this approach to the property setter when watching multiple, interacting input properties.
    
    Learn about `ngOnChanges` in the [LifeCycle Hooks](../guide/lifecycle-hooks.html) chapter.
:marked
  This `VersionChildComponent` detects changes to the `major` and `minor` input properties and composes a log message reporting these changes:
  
+makeExample('cb-component-communication/ts/app/version-child.component.ts')

:marked
  The `VersionParentComponent` supplies the `minor` and `major` values and binds buttons to methods that change them.
  
+makeExample('cb-component-communication/ts/app/version-parent.component.ts')

:marked
  Here's the output of a button-pushing sequence:
  
figure.image-display
  img(src="/resources/images/cookbooks/component-communication/parent-to-child-on-changes.gif" alt="Parent-to-child-onchanges")
  
:marked
  ### Test it
  
  Test that ***both*** input properties are set initially and that button clicks trigger 
  the expected `ngOnChanges` calls and values:
  
+makeExample('cb-component-communication/e2e-spec.ts', 'parent-to-child-onchanges')

:marked
  [Back to top](#top)

.l-main-section
<a id="child-to-parent"></a>
:marked
  ## Parent listens for child event

  The child component exposes an `EventEmitter` property with which it `emits`events when something happens. 
  The parent binds to that event property and reacts to those events.
  
  The child's `EventEmitter` property is an ***output property***, 
    typically adorned with an [@Output decoration](../guide/template-syntax.html#inputs-outputs)
    as seen in this `VoterComponent`:
  
+makeExample('cb-component-communication/ts/app/voter.component.ts')

:marked
  Clicking a button triggers emission of a `true` or `false` (the boolean *payload*).
  
  The parent `VoteTakerComponent` binds an event handler (`onVoted`) that responds to the child event
  payload (`$event`) and updates a counter.
  
+makeExample('cb-component-communication/ts/app/votetaker.component.ts')

:marked
  The framework passes the event argument &mdash; represented by `$event` &mdash; to the handler method, 
  and the method processes it:
  
figure.image-display
  img(src="/resources/images/cookbooks/component-communication/child-to-parent.gif" alt="Child-to-parent")
  
:marked
  ### Test it
  
  Test that clicking the *Agree* and *Disagree* buttons update the appropriate counters:
  
+makeExample('cb-component-communication/e2e-spec.ts', 'child-to-parent')

:marked
  [Back to top](#top)

.l-main-section#parent-to-child-local-var
:marked
  ## Parent interacts with child via *local variable*
  
  A parent component cannot use data binding to read child properties
  or invoke child methods. We can do both 
  by creating a template reference variable for the child element
  and then reference that variable *within the parent template*
  as seen in the following example.

  <a id="countdown-timer-example"></a>
  We have a child `CountdownTimerComponent` that repeatedly counts down to zero and launches a rocket.
  It has `start` and `stop` methods that control the clock and it displays a
  countdown status message in its own template.
+makeExample('cb-component-communication/ts/app/countdown-timer.component.ts')
:marked
  Let's see the `CountdownLocalVarParentComponent` that hosts the timer component.
  
+makeExample('cb-component-communication/ts/app/countdown-parent.component.ts', 'lv')
:marked
  The parent component cannot data bind to the child's 
  `start` and `stop` methods nor to its `seconds` property.
  
  We can place a local variable (`#timer`) on the tag (`<countdown-timer>`) representing the child component.
  That gives us a reference to the child component itself and the ability to access
  *any of its properties or methods* from within the parent template.
 
  In this example, we wire parent buttons to the child's `start` and `stop` and
  use interpolation to display the child's `seconds` property.
  
  Here we see the parent and child working together.

figure.image-display
  img(src="/resources/images/cookbooks/component-communication/countdown-timer-anim.gif" alt="countdown timer")

a(id="countdown-tests")
:marked
  ### Test it
  
  Test that the seconds displayed in the parent template
  match the seconds displayed in the child's status message.
  Test also that clicking the *Stop* button pauses the countdown timer:
  
+makeExample('cb-component-communication/e2e-spec.ts', 'countdown-timer-tests')

:marked
  [Back to top](#top)
  
.l-main-section
<a id="parent-to-view-child"></a>
:marked
  ## Parent calls a *ViewChild*
  
  The *local variable* approach is simple and easy. But it is limited because 
  the parent-child wiring must be done entirely within the parent template.
  The parent component *itself* has no access to the child.
  
  We can't use the *local variable* technique if an instance of the parent component *class*
  must read or write child component values or must call child component methods.
  
  When the parent component *class* requires that kind of access, 
  we ***inject*** the child component into the parent as a *ViewChild*.
  
  We'll illustrate this technique with the same [Countdown Timer](#countdown-timer-example) example. 
  We won't change its appearance or behavior. 
  The child [CountdownTimerComponent](#countdown-timer-example) is the same as well.
.l-sub-section
  :marked
    We are switching from the *local variable* to the *ViewChild* technique
    solely for the purpose of demonstration.
:marked
  Here is the parent, `CountdownViewChildParentComponent`:
+makeExample('cb-component-communication/ts/app/countdown-parent.component.ts', 'vc')
:marked
  It takes a bit more work to get the child view into the parent component *class*.
   
  We import references to the `ViewChild` decorator and the `AfterViewInit` lifecycle hook.
  
  We inject the child `CountdownTimerComponent` into the private `timerComponent` property
  via the `@ViewChild` property decoration.
  
  The `#timer` local variable is gone from the component metadata. 
  Instead we bind the buttons to the parent component's own `start` and `stop` methods and
  present the ticking seconds in an interpolation around the parent component's `seconds` method.
  
  These methods access the injected timer component directly.
  
  The `ngAfterViewInit` lifecycle hook is an important wrinkle.
  The timer component isn't available until *after* Angular displays the parent view.
  So we display `0` seconds initially.
  
  Then Angular calls the `ngAfterViewInit` lifecycle hook at which time it is *too late*
  to update the parent view's display of the countdown seconds.
  Angular's unidirectional data flow rule prevents us from updating the parent view's
  in the same cycle. We have to *wait one turn* before we can display the seconds.
  
  We use `setTimeout` to wait one tick and then revise the `seconds` method so 
  that it takes future values from the timer component.

  ### Test it
  Use [the same countdown timer tests](#countdown-tests) as before.
:marked
  [Back to top](#top)
  
.l-main-section
<a id="bidirectional-service"></a>
:marked
  ## Parent and children communicate via a service

  A parent component and its children share a service whose interface enables bi-directional communication
  *within the family*.

  The scope of the service instance is the parent component and its children. 
  Components outside this component subtree have no access to the service or their communications.
  
  This `MissionService` connects the `MissionControlComponent` to multiple `AstronautComponent` children.

+makeExample('cb-component-communication/ts/app/mission.service.ts')
:marked
  The `MissionControlComponent` both provides the instance of the service that it shares with its children
  (through the `providers` metadata array) and injects that instance into itself through its constructor:
  
+makeExample('cb-component-communication/ts/app/missioncontrol.component.ts')

:marked
  The `AstronautComponent` also injects the service in its constructor.
  Each `AstronautComponent` is a child of the `MissionControlComponent` and therefore receives its parent's service instance:
  
+makeExample('cb-component-communication/ts/app/astronaut.component.ts')

.l-sub-section
  :marked
    Notice that we capture the `subscription` and unsubscribe when the `AstronautComponent` is destroyed.
    This is a memory-leak guard step. There is no actual risk in this app because the
    lifetime of a `AstronautComponent` is the same as the lifetime of the app itself.
    That *would not* always be true in a more complex application.
    
    We do not add this guard to the `MissionControlComponent` because, as the parent,
    it controls the lifetime of the `MissionService`.
:marked
  The *History* log demonstrates that messages travel in both directions between
  the parent `MissionControlComponent` and the `AstronautComponent` children,
  facilitated by the service:
  
figure.image-display
  img(src="/resources/images/cookbooks/component-communication/bidirectional-service.gif" alt="bidirectional-service")
  
:marked
  ### Test it
  
  Tests click buttons of both the parent `MissionControlComponent` and the `AstronautComponent` children
  and verify that the *History* meets expectations:
  
+makeExample('cb-component-communication/e2e-spec.ts', 'bidirectional-service')

:marked
  [Back to top](#top)
